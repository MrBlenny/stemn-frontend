{"version":3,"sources":["app\\renderer\\main\\modules\\Tasks\\TaskList\\TaskGroup\\TaskGroupWrapped.jsx"],"names":[],"mappings":"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","file":"TaskGroupWrapped.jsx","sourceRoot":"C:/Users/david/repositories/stemn-electron-2","sourcesContent":["import React, { Component, PropTypes } from 'react';\nimport { DragSource, DropTarget } from 'react-dnd';\nimport { findDOMNode } from 'react-dom';\n\nconst ItemTypes = {\n  GROUP: 'group'\n}\n\nlet endDragProps = {};\nlet beginDragProps = {};\n\nconst cardSource = {\n  beginDrag(props) {\n    beginDragProps.id = props.id;\n    beginDragProps.index = props.index;\n    return {\n      id: props.id,\n      index: props.index\n    };\n  },\n\n  endDrag(props) {\n    // If the group has moved, save it\n    if(beginDragProps.index != endDragProps.index){\n      props.moveGroup({\n        group: beginDragProps.id,\n        destinationGroup: endDragProps.id,\n        after: endDragProps.after,\n        save: true\n      });\n    }\n  }\n};\n\nconst cardTarget = {\n  hover(props, monitor, component){\n    const dragIndex = monitor.getItem().index;\n    const hoverIndex = props.index;\n    // Don't replace items with themselves\n    if (dragIndex === hoverIndex) {\n      return;\n    }\n    // Determine rectangle on screen\n    const hoverBoundingRect = findDOMNode(component).getBoundingClientRect();\n    const clientOffset = monitor.getClientOffset(); // Determine mouse position\n\n    if(props.layout == 'list'){\n      const hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2; // Get vertical middle\n      const hoverClientY = clientOffset.y - hoverBoundingRect.top; // Get pixels to the top\n      // Only perform the move when the mouse has crossed half of the items height\n      if (dragIndex < hoverIndex && hoverClientY < hoverMiddleY) { return } // Dragging down\n      if (dragIndex > hoverIndex && hoverClientY > hoverMiddleY) { return } // Dragging upwards\n    }\n    // Else this is a board (horizontal drag)\n    else{\n      const hoverMiddleX = (hoverBoundingRect.right - hoverBoundingRect.left) / 2;\n      const hoverClientX = clientOffset.x - hoverBoundingRect.left; // Get pixels to the left\n      // Only perform the move when the mouse has crossed half of the items height\n      if (dragIndex < hoverIndex && hoverClientX < hoverMiddleX) { return } // Dragging left\n      if (dragIndex > hoverIndex && hoverClientX > hoverMiddleX) { return } // Dragging right\n    }\n\n\n    // Set the end params\n    endDragProps.id = props.id;\n    endDragProps.index = props.index;\n    // If the dragged item index is less than the destination index, we set it to after\n    const dragIndexInGroup = props.groups.findIndex(groupId => groupId == beginDragProps.id);\n    endDragProps.after = dragIndexInGroup != -1 ? dragIndexInGroup < endDragProps.index : false;\n\n    // Time to actually perform the action\n    props.moveGroup({\n      group: monitor.getItem().id,\n      destinationGroup: props.id\n    });\n    monitor.getItem().index = hoverIndex;\n  }\n};\n\n@DropTarget(ItemTypes.GROUP, cardTarget, connect => ({\n  connectDropTarget: connect.dropTarget()\n}))\n@DragSource(ItemTypes.GROUP, cardSource, (connect, monitor) => ({\n  connectDragSource: connect.dragSource(),\n  isDragging: monitor.isDragging()\n}))\nexport default class Card extends Component {\n  static propTypes = {\n    connectDragSource: PropTypes.func.isRequired,\n    connectDropTarget: PropTypes.func.isRequired,\n    index: PropTypes.number.isRequired,\n    isDragging: PropTypes.bool.isRequired,\n    item: PropTypes.object.isRequired,\n    moveGroup: PropTypes.func.isRequired,\n    layout: PropTypes.string.isRequired // Required to determine drag direction, horizontal or veritcal\n  };\n\n  render() {\n    const { item, isDragging, connectDragSource, connectDropTarget, children, id } = this.props;\n    const outerStyles = isDragging ? {opacity: '0.5'} : {opacity: '1', transform: 'translate3d(0,0,0)'};\n    return connectDragSource(connectDropTarget(\n      <div style={outerStyles} key={id}>\n        {children}\n      </div>\n    ));\n  }\n}\n"]}