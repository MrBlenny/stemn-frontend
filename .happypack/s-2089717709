'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = function () {
  var state = arguments.length <= 0 || arguments[0] === undefined ? initialState : arguments[0];
  var action = arguments[1];

  if (!state.hydrated) {
    state = _extends({}, initialState, state, { hydrated: true });
  }
  return (0, _reactReduxForm.modeled)(mainReducer, 'tasks')(state, action);
};

var _icepick = require('icepick');

var _icepick2 = _interopRequireDefault(_icepick);

var _lodash = require('lodash');

var _reactReduxForm = require('react-redux-form');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var initialState = {
  data: {},
  projects: {},
  events: {},
  boards: {
    /********************************
    boardId: {
      data: {the board data},
      searchString: 'Some search string'
      layout: 'board' || 'list'
    }
    ********************************/
  }

};

var mainReducer = function mainReducer(state, action) {
  switch (action.type) {
    case 'TASKS/NEW_TASK_FULFILLED':
      return _icepick2.default.chain(state).assocIn(['data', action.payload.data._id, 'data'], action.payload.data) // Add to data
      .assocIn(['boards', action.payload.data.board, 'newTaskString', action.payload.data.group], '') // Clear string
      .updateIn(['boards', action.payload.data.board, 'data', 'groups'], function (groups) {
        // Add to groups.tasks array
        var groupIndex = groups.findIndex(function (group) {
          return group._id == action.payload.data.group;
        });
        return _icepick2.default.updateIn(groups, [groupIndex, 'tasks'], function (tasks) {
          return _icepick2.default.push(tasks, action.payload.data._id);
        });
      }).value();

    case 'TASKS/GET_BOARD_PENDING':
      return _icepick2.default.assocIn(state, ['projects', action.meta.cacheKey, 'loading'], true);
    case 'TASKS/GET_BOARD_REJECTED':
      return _icepick2.default.assocIn(state, ['projects', action.meta.cacheKey, 'loading'], false);
    case 'TASKS/GET_BOARD_FULFILLED':
      return _icepick2.default.merge(state, {
        projects: _defineProperty({}, action.meta.cacheKey, {
          boards: [action.payload.data[0]._id],
          loading: false
        }),
        boards: _defineProperty({}, action.payload.data[0]._id, {
          data: action.payload.data[0]
        })
      });

    case 'TASKS/GET_TASK_PENDING':
      return _icepick2.default.assocIn(state, ['data', action.meta.cacheKey, 'loading'], true);
    case 'TASKS/GET_TASK_REJECTED':
      return _icepick2.default.assocIn(state, ['data', action.meta.cacheKey, 'loading'], false);
    case 'TASKS/GET_TASK_FULFILLED':
      return _icepick2.default.assocIn(state, ['data', action.meta.cacheKey], {
        data: action.payload.data,
        loading: false
      });

    case 'TASKS/GET_EVENTS_PENDING':
      return _icepick2.default.assocIn(state, ['events', action.meta.cacheKey, 'loading'], true);
    case 'TASKS/GET_EVENTS_REJECTED':
      return _icepick2.default.assocIn(state, ['events', action.meta.cacheKey, 'loading'], false);
    case 'TASKS/GET_EVENTS_FULFILLED':
      return _icepick2.default.assocIn(state, ['events', action.meta.cacheKey], {
        data: action.payload.data,
        loading: false
      });
    case 'TASKS/NEW_EVENT':
      return _icepick2.default.updateIn(state, ['events', action.payload.taskId, 'data'], function (events) {
        return _icepick2.default.push(events, action.payload.event);
      });

    case 'TASKS/DELETE_EVENT':
      return _icepick2.default.updateIn(state, ['events', action.payload.taskId, 'data'], function (events) {
        var eventIndex = events.findIndex(function (event) {
          return event._id == action.payload.eventId;
        });
        return eventIndex != -1 ? _icepick2.default.splice(events, eventIndex, 1) : events;
      });

    case 'TASKS/UPDATE_BOARD_PENDING':
      return _icepick2.default.assocIn(state, ['boards', action.meta.cacheKey, 'savePending'], true);
    case 'TASKS/UPDATE_BOARD_REJECTED':
      return _icepick2.default.assocIn(state, ['boards', action.meta.cacheKey, 'savePending'], false);
    case 'TASKS/UPDATE_BOARD_FULFILLED':
      return _icepick2.default.assocIn(state, ['boards', action.meta.cacheKey, 'savePending'], false);

    case 'TASKS/NEW_GROUP_FULFILLED':
      return _icepick2.default.chain(state)
      // Reset the newGroupString to empty
      .assocIn(['boards', action.meta.boardId, 'newGroupString'], '')
      // Push the new group onto the groups array
      .updateIn(['boards', action.meta.boardId, 'data', 'groups'], function (groups) {
        return _icepick2.default.push(groups, action.payload.data);
      }).value();

    case 'TASKS/DELETE_GROUP_FULFILLED':
      return _icepick2.default.updateIn(state, ['boards', action.meta.boardId, 'data', 'groups'], function (groups) {
        var groupIndex = groups.findIndex(function (group) {
          return group._id == action.meta.groupId;
        }); // Find the index of the group
        return _icepick2.default.splice(groups, groupIndex, 1); // Delete the group from the groups array
      });

    case 'TASKS/DELETE_TASK_FULFILLED':
      return _icepick2.default.chain(state).assocIn(['data', action.meta.taskId], undefined).updateIn(['boards', action.meta.boardId, 'data', 'groups'], function (groups) {
        var location = getLocationIndex(groups, action.meta.taskId);
        return _icepick2.default.updateIn(groups, [location.groupIndex, 'tasks'], function (tasks) {
          return _icepick2.default.splice(tasks, location.taskIndex, 1);
        });
      }).value();

    case 'TASKS/MOVE_TASK':
      return _icepick2.default.chain(state).assocIn(['data', action.payload.task, 'data', 'board'], action.payload.destinationGroup) // Update the group property
      .updateIn(['boards', action.payload.boardId, 'data', 'groups'], function (groups) {
        // Move the task in the groups array
        var from = getLocationIndex(groups, action.payload.task);
        var to = action.payload.destinationTask ? getLocationIndex(groups, action.payload.destinationTask) : { groupIndex: getGroupIndex(groups, action.payload.destinationGroup), taskIndex: 0 };
        return moveTask({
          groups: groups,
          lastX: from.groupIndex,
          nextX: to.groupIndex,
          lastY: from.taskIndex,
          nextY: to.taskIndex
        });
      }).value();
    case 'TASKS/MOVE_TASK_FULFILLED':
      return state;

    case 'TASKS/MOVE_GROUP':
      return _icepick2.default.updateIn(state, ['boards', action.payload.boardId, 'data', 'groups'], function (groups) {
        var groupFrom = groups.findIndex(function (group) {
          return group._id == action.payload.group;
        });
        var groupTo = groups.findIndex(function (group) {
          return group._id == action.payload.destinationGroup;
        });
        return moveGroup(groups, groupFrom, groupTo);
      });

    case 'TASKS/BEGIN_DRAG':
      return _icepick2.default.assocIn(state, ['data', action.payload.taskId, 'isDragging'], true);
    case 'TASKS/END_DRAG':
      return _icepick2.default.assocIn(state, ['data', action.payload.taskId, 'isDragging'], false);

    case 'TASKS/CHANGE_LAYOUT':
      return _icepick2.default.assocIn(state, ['boards', action.payload.boardId, 'layout'], action.payload.layout);

    default:
      return state;
  }
};

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////


function getLocationIndex(groups, id) {
  // This will return the group and task index inside the structure object.
  var groupIndex = null;
  var taskIndex = null;
  groupIndex = groups.findIndex(function (group, groupIndex) {
    var foundTaskIndex = group.tasks.findIndex(function (taskId) {
      return taskId == id;
    });
    // If the task index is found, we return it
    if (foundTaskIndex != -1) {
      taskIndex = foundTaskIndex;
      return true;
    }
  });
  return {
    groupIndex: groupIndex,
    taskIndex: taskIndex
  };
}

function getGroupIndex(groups, groupId) {
  return groups.findIndex(function (group) {
    return group._id == groupId;
  });
}

function moveTask(_ref) {
  var groups = _ref.groups;
  var lastX = _ref.lastX;
  var nextX = _ref.nextX;
  var lastY = _ref.lastY;
  var nextY = _ref.nextY;

  var cloneItems = (0, _lodash.cloneDeep)(groups);
  if (lastX === nextX) {
    cloneItems[lastX].tasks.splice(nextY, 0, cloneItems[lastX].tasks.splice(lastY, 1)[0]);
  } else {
    cloneItems[nextX].tasks.splice(nextY, 0, cloneItems[lastX].tasks[lastY]); // move element to new place
    cloneItems[lastX].tasks.splice(lastY, 1); // delete element from old place
  }
  return cloneItems;
}

function moveGroup(groups, fromIndex, toIndex) {
  var cloneItems = (0, _lodash.cloneDeep)(groups);
  var t = cloneItems.splice(fromIndex, 1)[0];
  cloneItems.splice(toIndex, 0, t);
  return cloneItems;
}

function addItem(keyItems, item) {
  return [].concat(keyItems, [item]);
}

module.exports = exports['default'];