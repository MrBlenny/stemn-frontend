{"version":3,"sources":["app\\renderer\\main\\modules\\Mentions\\MentionsInput\\utils.js"],"names":[],"mappings":"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","file":"utils.js","sourceRoot":"C:/Users/david/repositories/stemn-electron-2","sourcesContent":["var PLACEHOLDERS = {\n  id: \"__id__\",\n  display: \"__display__\",\n  type: \"__type__\"\n}\n\nvar escapeMap = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#x27;',\n  '`': '&#x60;'\n};\nvar createEscaper = function(map) {\n  var escaper = function(match) {\n    return map[match];\n  };\n  var keys = [];\n  for(var key in map) {\n    if(map.hasOwnProperty(key)) keys.push(key);\n  }\n  var source = '(?:' + keys.join('|') + ')';\n  var testRegexp = RegExp(source);\n  var replaceRegexp = RegExp(source, 'g');\n  return function(string) {\n    string = string == null ? '' : '' + string;\n    return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n  };\n};\n\nvar numericComparator = function(a, b) {\n  a = a === null ? Number.MAX_VALUE : a;\n  b = b === null ? Number.MAX_VALUE : b;\n  return a - b;\n};\n\nmodule.exports = {\n\n  escapeHtml: createEscaper(escapeMap),\n\n  escapeRegex: function(str) {\n      return str.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n  },\n\n  markupToRegex: function(markup, matchAtEnd) {\n    var markupPattern = this.escapeRegex(markup);\n    markupPattern = markupPattern.replace(PLACEHOLDERS.display, \"(.+?)\");\n    markupPattern = markupPattern.replace(PLACEHOLDERS.id, \"(.+?)\");\n    markupPattern = markupPattern.replace(PLACEHOLDERS.type, \"(.+?)\");\n    if(matchAtEnd) {\n      // append a $ to match at the end of the string\n      markupPattern = markupPattern + \"$\";\n    }\n    return new RegExp(markupPattern, \"g\");\n  },\n\n  spliceString: function(str, start, end, insert) {\n    return str.substring(0, start) + insert + str.substring(end);\n  },\n\n  extend: function(obj) {\n    var source, prop;\n    for (var i = 1, length = arguments.length; i < length; i++) {\n      source = arguments[i];\n      for (prop in source) {\n        if (hasOwnProperty.call(source, prop)) {\n            obj[prop] = source[prop];\n        }\n      }\n    }\n    return obj;\n  },\n\n  isNumber: function(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Number]\";\n  },\n\n  /**\n   * parameterName: \"id\", \"display\", or \"type\"\n   */\n  getPositionOfCapturingGroup: function(markup, parameterName) {\n    if(parameterName !== \"id\" && parameterName !== \"display\" && parameterName !== \"type\") {\n      throw new Error(\"parameterName must be 'id', 'display', or 'type'\");\n    }\n\n    // calculate positions of placeholders in the markup\n    var indexDisplay = markup.indexOf(PLACEHOLDERS.display);\n    var indexId = markup.indexOf(PLACEHOLDERS.id);\n    var indexType = markup.indexOf(PLACEHOLDERS.type);\n\n    // set indices to null if not found\n    if(indexDisplay < 0) indexDisplay = null;\n    if(indexId < 0) indexId = null;\n    if(indexType < 0) indexType = null;\n\n    if(indexDisplay === null && indexId === null) {\n      // markup contains none of the mandatory placeholders\n      throw new Error(\"The markup `\" + markup + \"` must contain at least one of the placeholders `__id__` or `__display__`\");\n    }\n\n    if(indexType === null && parameterName === \"type\") {\n      // markup does not contain optional __type__ placeholder\n      return null;\n    }\n\n    // sort indices in ascending order (null values will always be at the end)\n    var sortedIndices = [indexDisplay, indexId, indexType].sort(numericComparator);\n\n    // If only one the placeholders __id__ and __display__ is present,\n    // use the captured string for both parameters, id and display\n    if(indexDisplay === null) indexDisplay = indexId;\n    if(indexId === null) indexId = indexDisplay;\n\n    if(parameterName === \"id\") return sortedIndices.indexOf(indexId);\n    if(parameterName === \"display\") return sortedIndices.indexOf(indexDisplay);\n    if(parameterName === \"type\") return indexType === null ? null : sortedIndices.indexOf(indexType);\n\n  },\n\n  // Finds all occurences of the markup in the value and iterates the plain text sub strings\n  // in between those markups using `textIteratee` and the markup occurrences using the\n  // `markupIteratee`.\n  iterateMentionsMarkup: function(value, markup, textIteratee, markupIteratee, displayTransform) {\n    var regex = this.markupToRegex(markup);\n    var displayPos = this.getPositionOfCapturingGroup(markup, \"display\");\n    var idPos = this.getPositionOfCapturingGroup(markup, \"id\");\n    var typePos = this.getPositionOfCapturingGroup(markup, \"type\");\n\n    var match;\n    var start = 0;\n    var currentPlainTextIndex = 0;\n\n    // detect all mention markup occurences in the value and iterate the matches\n    while((match = regex.exec(value)) !== null) {\n\n      var id = match[idPos+1];\n      var display = match[displayPos+1];\n      var type = typePos !== null ? match[typePos+1] : null;\n\n      if(displayTransform) display = displayTransform(id, display, type);\n\n      var substr = value.substring(start, match.index);\n      textIteratee( substr, start, currentPlainTextIndex );\n      currentPlainTextIndex += substr.length;\n\n      markupIteratee( match[0], match.index, currentPlainTextIndex, id, display, type, start );\n      currentPlainTextIndex += display.length;\n\n      start = regex.lastIndex;\n    }\n\n    if(start < value.length) {\n      textIteratee( value.substring(start), start, currentPlainTextIndex );\n    }\n  },\n\n  // For the passed character index in the plain text string, returns the corresponding index\n  // in the marked up value string.\n  // If the passed character index lies inside a mention, the value of `inMarkupCorrection` defines the\n  // correction to apply:\n  //   - 'START' to return the index of the mention markup's first char (default)\n  //   - 'END' to return the index after its last char\n  //   - 'NULL' to return null\n  mapPlainTextIndex: function(value, markup, indexInPlainText, inMarkupCorrection='START', displayTransform) {\n    if(!this.isNumber(indexInPlainText)) {\n      return indexInPlainText;\n    }\n\n    var result;\n    var textIteratee = function(substr, index, substrPlainTextIndex) {\n      if(result !== undefined) return;\n\n      if(substrPlainTextIndex + substr.length >= indexInPlainText) {\n        // found the corresponding position in the current plain text range\n        result = index + indexInPlainText - substrPlainTextIndex;\n      }\n    };\n    var markupIteratee = function(markup, index, mentionPlainTextIndex, id, display, type, lastMentionEndIndex) {\n      if(result !== undefined) return;\n\n      if(mentionPlainTextIndex + display.length > indexInPlainText) {\n        // found the corresponding position inside current match,\n        // return the index of the first or after the last char of the matching markup\n        // depending on whether the `inMarkupCorrection`\n        if(inMarkupCorrection === 'NULL') {\n          result = null;\n        } else {\n          result = index + (inMarkupCorrection === 'END' ? markup.length : 0);\n        }\n      }\n    };\n\n    this.iterateMentionsMarkup(value, markup, textIteratee, markupIteratee, displayTransform);\n\n    // when a mention is at the end of the value and we want to get the caret position\n    // at the end of the string, result is undefined\n    return result === undefined ? value.length : result;\n  },\n\n  // For a given indexInPlainText that lies inside a mention,\n  // returns a the index of of the first char of the mention in the plain text.\n  // If indexInPlainText does not lie inside a mention, returns indexInPlainText.\n  findStartOfMentionInPlainText: function(value, markup, indexInPlainText, displayTransform) {\n    var result = indexInPlainText;\n    var foundMention = false;\n\n    var markupIteratee = function(markup, index, mentionPlainTextIndex, id, display, type, lastMentionEndIndex) {\n      if(mentionPlainTextIndex < indexInPlainText && mentionPlainTextIndex + display.length > indexInPlainText) {\n        result = mentionPlainTextIndex;\n        foundMention = true;\n      }\n    };\n    this.iterateMentionsMarkup(value, markup, function(){}, markupIteratee, displayTransform);\n\n    if (foundMention) {\n      return result;\n    }\n  },\n\n  // Returns whether the given plain text index lies inside a mention\n  isInsideOfMention: function(value, markup, indexInPlainText, displayTransform) {\n    var mentionStart = this.findStartOfMentionInPlainText(value, markup, indexInPlainText, displayTransform);\n    return mentionStart !== undefined && mentionStart !== indexInPlainText\n  },\n\n  // Applies a change from the plain text textarea to the underlying marked up value\n  // guided by the textarea text selection ranges before and after the change\n  applyChangeToValue: function(value, markup, plainTextValue, selectionStartBeforeChange, selectionEndBeforeChange, selectionEndAfterChange, displayTransform) {\n    var oldPlainTextValue = this.getPlainText(value, markup, displayTransform);\n\n    var lengthDelta = oldPlainTextValue.length - plainTextValue.length;\n    if (selectionStartBeforeChange === 'undefined') {\n      selectionStartBeforeChange = selectionEndAfterChange + lengthDelta;\n    }\n\n    if (selectionEndBeforeChange === 'undefined') {\n      selectionEndBeforeChange = selectionStartBeforeChange;\n    }\n\n    // Fixes an issue with replacing combined characters for complex input. Eg like acented letters on OSX\n    if (selectionStartBeforeChange === selectionEndBeforeChange &&\n      selectionEndBeforeChange === selectionEndAfterChange &&\n      oldPlainTextValue.length === plainTextValue.length\n    ) {\n      selectionStartBeforeChange = selectionStartBeforeChange - 1;\n    }\n\n    // extract the insertion from the new plain text value\n    var insert = plainTextValue.slice(selectionStartBeforeChange, selectionEndAfterChange);\n\n    // handling for Backspace key with no range selection\n    var spliceStart = Math.min(selectionStartBeforeChange, selectionEndAfterChange);\n\n    var spliceEnd = selectionEndBeforeChange;\n    if(selectionStartBeforeChange === selectionEndAfterChange) {\n      // handling for Delete key with no range selection\n      spliceEnd = Math.max(selectionEndBeforeChange, selectionStartBeforeChange + lengthDelta);\n    }\n\n    var mappedSpliceStart = this.mapPlainTextIndex(value, markup, spliceStart, 'START', displayTransform);\n    var mappedSpliceEnd = this.mapPlainTextIndex(value, markup, spliceEnd, 'END', displayTransform);\n\n    var controlSpliceStart = this.mapPlainTextIndex(value, markup, spliceStart, 'NULL', displayTransform);\n    var controlSpliceEnd = this.mapPlainTextIndex(value, markup, spliceEnd, 'NULL', displayTransform);\n    var willRemoveMention = controlSpliceStart === null || controlSpliceEnd === null;\n\n    var newValue = this.spliceString(value, mappedSpliceStart, mappedSpliceEnd, insert);\n\n    if(!willRemoveMention) {\n      // test for auto-completion changes\n      var controlPlainTextValue = this.getPlainText(newValue, markup, displayTransform);\n      if(controlPlainTextValue !== plainTextValue) {\n        // some auto-correction is going on\n\n        // find start of diff\n        spliceStart = 0;\n        while(plainTextValue[spliceStart] === controlPlainTextValue[spliceStart])\n          spliceStart++\n\n        // extract auto-corrected insertion\n        insert = plainTextValue.slice(spliceStart, selectionEndAfterChange)\n\n        // find index of the unchanged remainder\n        spliceEnd = oldPlainTextValue.lastIndexOf(plainTextValue.substring(selectionEndAfterChange))\n\n        // re-map the corrected indices\n        mappedSpliceStart = this.mapPlainTextIndex(value, markup, spliceStart, 'START', displayTransform);\n        mappedSpliceEnd = this.mapPlainTextIndex(value, markup, spliceEnd, 'END', displayTransform);\n        newValue = this.spliceString(value, mappedSpliceStart, mappedSpliceEnd, insert);\n      }\n    }\n\n    return newValue;\n  },\n\n  getPlainText: function(value, markup, displayTransform) {\n    var regex = this.markupToRegex(markup);\n    var idPos = this.getPositionOfCapturingGroup(markup, \"id\");\n    var displayPos = this.getPositionOfCapturingGroup(markup, \"display\");\n    var typePos = this.getPositionOfCapturingGroup(markup, \"type\");\n    return value.replace(regex, function() {\n      // first argument is the whole match, capturing groups are following\n      var id = arguments[idPos+1];\n      var display = arguments[displayPos+1];\n      var type = arguments[typePos+1];\n      if(displayTransform) display = displayTransform(id, display, type);\n      return display;\n    });\n  },\n\n  getMentions: function (value, markup) {\n    var mentions = [];\n    this.iterateMentionsMarkup(value, markup, function (){}, function (match, index, plainTextIndex, id, display, type, start) {\n      mentions.push({\n        id: id,\n        display: display,\n        type: type,\n        index: index,\n        plainTextIndex: plainTextIndex\n      });\n    });\n    return mentions;\n  },\n\n  makeMentionsMarkup: function(markup, id, display, type) {\n    var result = markup.replace(PLACEHOLDERS.id, id);\n    result = result.replace(PLACEHOLDERS.display, display);\n    result = result.replace(PLACEHOLDERS.type, type);\n    return result;\n  },\n\n  countSuggestions: function(suggestions) {\n    let result = 0;\n    for(let prop in suggestions) {\n      if(suggestions.hasOwnProperty(prop)) {\n        result += suggestions[prop].results.length;\n      }\n    }\n    return result;\n  },\n\n  getSuggestions: function(suggestions) {\n    var result = [];\n\n    for(var mentionType in suggestions) {\n      if(!suggestions.hasOwnProperty(mentionType)) {\n        return;\n      }\n\n      result = result.concat({\n        suggestions: suggestions[mentionType].results,\n        descriptor: suggestions[mentionType]\n      });\n    }\n\n    return result;\n  },\n\n  getSuggestion: function(suggestions, index) {\n    return this.getSuggestions(suggestions).reduce((result, { suggestions, descriptor }) => [\n      ...result,\n\n      ...suggestions.map((suggestion) => ({\n        suggestion: suggestion,\n        descriptor: descriptor\n      }))\n    ], [])[index];\n  }\n\n}\n"]}