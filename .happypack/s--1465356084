'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addMentionsToText = exports.removeExistingMentions = exports.parseMentions = exports.getMentionString = exports.validateMention = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _isUuid = require('../../../../shared/helpers/isUuid.js');

var _isUuid2 = _interopRequireDefault(_isUuid);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var validateMention = exports.validateMention = function validateMention(href) {
  // mention should be of the form 'entityId:entityType:mentionId'
  // Example: '47db55af7f342380174e228:user:cb4e8fac7fe980b53da95624'
  // Boths ids should be 24 characters.
  var hrefSplit = href.split(':');
  if (hrefSplit.length == 3) {
    var _hrefSplit = _slicedToArray(hrefSplit, 3);

    var entityId = _hrefSplit[0];
    var mentionType = _hrefSplit[1];
    var mentionId = _hrefSplit[2];

    if ((0, _isUuid2.default)(entityId) && (0, _isUuid2.default)(mentionId)) {
      return true;
    } else {
      return false;
    }
  } else {
    return false;
  }
};

var getMentionString = exports.getMentionString = function getMentionString(mention) {
  return '@[' + mention.display + '](' + mention.entityId + ':' + mention.mentionType + ':' + mention.mentionId + ')';
};

var parseMentions = exports.parseMentions = function parseMentions(text) {
  /*
  text = text.match(/
      (                           // wrap whole match in $1
          \[
          (
              (?:
                  \[[^\]]*\]      // allow brackets nested one level
                  |
                  [^\[\]]         // or anything else
              )*
          )
          \]
          \(                      // literal paren
          [ \t]*
          ()                      // no id, so leave $3 empty
          <?(                     // href = $4
              (?:
                  \([^)]*\)       // allow one level of (correctly nested) parens (think MSDN)
                  |
                  [^()\s]
              )*?
          )>?
          [ \t]*
          (                       // $5
              (['"])              // quote char = $6
              (.*?)               // Title = $7
              \6                  // matching quote
              [ \t]*              // ignore any spaces/tabs between closing quote and )
          )?                      // title is optional
          \)
      )
  /g);
  */

  // Get the markdown links
  var mentionsRaw = text ? text.match(/(\[((?:\[[^\]]*\]|[^\[\]])*)\]\([ \t]*()<?((?:\([^)]*\)|[^()\s])*?)>?[ \t]*((['"])(.*?)\6[ \t]*)?\))/g) : [];
  var mentions = [];
  if (mentionsRaw && mentionsRaw.length > 0) {
    mentionsRaw.forEach(function (mention) {
      var display = mention.split('[')[1].split(']')[0]; // Get the name (from between the square brackets)
      var infoString = mention.split('(')[1].split(')')[0]; // Get the info (from between the standard brackets)
      if (validateMention(infoString)) {
        var _infoString$split = infoString.split(':');

        var _infoString$split2 = _slicedToArray(_infoString$split, 3);

        var entityId = _infoString$split2[0];
        var mentionType = _infoString$split2[1];
        var mentionId = _infoString$split2[2];

        mentions.push({
          display: display,
          entityId: entityId,
          mentionType: mentionType,
          mentionId: mentionId
        });
      }
    });
  }
  return mentions;
};

var removeExistingMentions = exports.removeExistingMentions = function removeExistingMentions(newMentions, existingMentions) {
  // Create an array of existing mention entity Ids
  var existingMentionEntityIds = existingMentions.map(function (mention) {
    return mention.entityId;
  });
  // Make sure new mentions do not already exist
  return newMentions.filter(function (mention) {
    return existingMentionEntityIds.indexOf(mention.entityId) == -1;
  });
};

var addMentionsToText = exports.addMentionsToText = function addMentionsToText(text, mentions) {
  var textNew = text || '';
  if (mentions && mentions.length > 0) {
    mentions.forEach(function (mention) {
      textNew = textNew.concat('' + (textNew.length > 0 ? ' ' : '') + getMentionString(mention));
    });
  }
  return textNew;
};